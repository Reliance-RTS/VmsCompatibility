;;*****************************************************************************
;;
;; Title:       VMSSYSTEM.DBL
;;
;; Type:        OpenVMS Compatibility Shims
;;
;; Description: Prototype definitions for unimplemented OpenVMS System Routines
;;
;; Author:      Roger Andrews, Synergex Development
;;              http://www.synergex.com
;;
;;*****************************************************************************
;;
;; Copyright (c) 2017, Synergex International, Inc.
;; All rights reserved.
;;
;; Redistribution and use in source and binary forms, with or without
;; modification, are permitted provided that the following conditions are met:
;;
;; * Redistributions of source code must retain the above copyright notice,
;;   this list of conditions and the following disclaimer.
;;
;; * Redistributions in binary form must reproduce the above copyright notice,
;;   this list of conditions and the following disclaimer in the documentation
;;   and/or other materials provided with the distribution.
;;
;; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
;; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;; POSSIBILITY OF SUCH DAMAGE.
;;
;;*****************************************************************************
.include "synergyitemlist" library "dblstarlet"
.define FABSTRUCT
.include "FABDEF" library "DBLSTARLET"
.ifndef dblnet
.define default optional
.endc
;;-----------------------------------------------------------------------------
;;Access Control List Editor (ACLEDIT$) Routines (See Utility Routines Manual)

;ACLEDIT$EDIT

;;-----------------------------------------------------------------------------
;;Backup (BACKUP$) Routines (See Utility Routines Manual)

;BACKUP$START

;;-----------------------------------------------------------------------------
;;Command Language Interface (CLI$) Routines (See Utility Routines Manual)

;CLI$DCL_PARSE
;CLI$DISPATCH


;;-----------------------------------------------------------------------------
;;Common File Qualifier (UTIL$CQUAL) Routines (See Utility Routines Manual)

;UTIL$CQUAL_FILE_PARSE
;UTIL$CQUAL_FILE_MATCH
;UTIL$CQUAL_FILE_END.
;UTIL$CQUAL_CONFIRM_ACT

;;-----------------------------------------------------------------------------
;;Convert (CONV$) Routines (See Utility Routines Manual)

;CONV$CONVERT
;CONV$PASS_FILES
;CONV$PASS_OPTIONS
;CONV$RECLAIM

;;-----------------------------------------------------------------------------
;;CVT$ routines (See the LIB$ manual)

;CVT$CONVERT_FLOAT
;CVT$FTOF

;;-----------------------------------------------------------------------------
;;Data Compression/Expansion (DCX$) Routines (See Utility Routines Manual)

;DCX$ANALYZE_DATA
;DCX$ANALYZE_DONE
;DCX$ANALYZE_INIT
;DCX$COMPRESS_DATA
;DCX$COMPRESS_DONE
;DCX$COMPRESS_INIT
;DCX$EXPAND_DATA
;DCX$EXPAND_DONE
;DCX$EXPAND_INIT
;DCX$MAKE_MAP

;;-----------------------------------------------------------------------------
;;File Definition Language (FDL$) routines (See Utility Routines Manual)

;;; <summary>
;;;
;;; </summary>
;;; <param name="fdlstring"></param>
;;; <param name="filename"></param>
;;; <param name="defaultname"></param>
;;; <param name="resultname"></param>
;;; <param name="fid_block"></param>
;;; <param name="flags"></param>
;;; <param name="stmt_num"></param>
;;; <param name="retlen"></param>
;;; <param name="sts"></param>
;;; <param name="stv"></param>
;;; <param name="default_fdl"></param>
;;; <returns></returns>
function FDL$CREATE                     ,^val
    required in  fdlstring              ,a
    optional in  filename               ,a
    optional in  defaultname            ,a
    optional out resultname             ,a
.ifndef dblnet
    optional out ^ref(fid_block)        ,int
    optional in  ^ref(flags)            ,int
    optional out ^ref(stmt_num)         ,int
    optional out ^ref(retlen)           ,short
    optional out ^ref(sts)              ,int
    optional out ^ref(stv)              ,int
    optional in  default_fdl            ,a
.endc

proc
    throw new ApplicationException("Not implemented!")
    freturn 0
endfunction

;FDL$GENERATE
;FDL$PARSE
;FDL$RELEASE

;;-----------------------------------------------------------------------------
;; Runtime Library (LIB$) Routines

;LIB$ADAWI
;LIB$ADDX
;LIB$ANALYZE_SDESC
;LIB$ANALYZE_SDESC_64
;LIB$ASN_WTH_MBX
;LIB$AST_IN_PROG

;;; <summary>
;;;
;;; </summary>
;;; <param name="processid"></param>
;;; <returns></returns>
.ifndef dblnet
function LIB$ATTACH                     ,^val
    required in  ^ref(processid)        ,i4
proc
	;
	; not possible off VMS
    throw new ApplicationException("Not implemented!")
    freturn 0
endfunction
.endc
;LIB$BBCCI

;;; <summary>
;;;
;;; </summary>
;;; <param name="position"></param>
;;; <param name="bitaddress"></param>
;;; <returns></returns>
function LIB$BBSSI                      ,^val
    required in  ^ref(position)         ,int
    required in  ^ref(bitaddress)       ,D_ADDR	; address of bitaddress
proc
    throw new ApplicationException("Not implemented!")
    freturn 0
endfunction

;LIB$BUILD_NODESPEC
;LIB$CALLG
;LIB$CALLG_64
;LIB$CHAR
;LIB$COMPARE_NODENAME
;LIB$COMPRESS_NODENAME
;LIB$CRC
;LIB$CRC_TABLE

;;; <summary>
;;;
;;; </summary>
;;; <param name="directory_spec"></param>
;;; <param name="uic"></param>
;;; <param name="Protectionenable"></param>
;;; <param name="proectionvalue"></param>
;;; <param name="maxversions"></param>
;;; <param name="volume_numner"></param>
;;; <param name="initialsize"></param>
;;; <returns></returns>
function LIB$CREATE_DIR                 ,^val
    required in  directory_spec         ,a
.ifndef dblnet
    optional in  ^ref(uic)              ,int
    optional in  ^ref(Protectionenable) ,short
    optional in  ^ref(protectionvalue)   ,short
    optional in  ^ref(maxversions)      ,short
    optional in  ^ref(volume_numner)    ,short
    optional in  ^ref(initialsize)      ,int
.endc
proc
    throw new ApplicationException("Not implemented!")
    freturn 0
endfunction

;LIB$CREATE_USER_VM_ZONE
;LIB$CREATE_USER_VM_ZONE_64
;LIB$CREATE_VM_ZONE
;LIB$CREATE_VM_ZONE_64
;LIB$CRF_INS_KEY
;LIB$CRF_INS_REF
;LIB$CRF_OUTPUT
;LIB$CVTF_FROM_INTERNAL_TIME
;LIB$CVTS_FROM_INTERNAL_TIME
;LIB$CVTF_TO_INTERNAL_TIME
;LIB$CVTS_TO_INTERNAL_TIME
;LIB$CVT_FROM_INTERNAL_TIME
;LIB$CVT_TO_INTERNAL_TIME

;;; <summary>
;;;
;;; </summary>
;;; <param name="inputtime"></param>
;;; <param name="resulttime"></param>
;;; <returns></returns>
.ifndef dblnet
function LIB$CVT_VECTIM                 ,^val
    required in  ^ref(inputtime)        ,[*]short
    required out ^ref(resulttime)       ,long
proc
    throw new ApplicationException("Not implemented!")
    freturn 0
endfunction
.endc

;LIB$CVT_xTB
;LIB$CVT_xTB_64

;;; <summary>
;;;
;;; </summary>
;;; <param name="number_of_days"></param>
;;; <param name="day_time"></param>
;;; <returns></returns>
function LIB$DAY                        ,^val
    out %ref(number_of_days)            ,int
    out %ref(day_time)                  ,long
    endparams
proc
    throw new ApplicationException("Not implemented!")
    freturn 0
endfunction

;LIB$DECODE_FAULT
;LIB$DEC_OVER
;LIB$DELETE_VM_ZONE
;LIB$DELETE_VM_ZONE_64
;LIB$DIGIT_SEP
;LIB$DISABLE_CTRL
;LIB$EDIV
;LIB$EMODD
;LIB$EMODF
;LIB$EMODG
;LIB$EMODH
;LIB$EMODS
;LIB$EMODT
;LIB$EMUL
;LIB$ENABLE_CTRL
;LIB$ESTABLISH
;LIB$EXPAND_NODENAME
;LIB$EXTV
;LIB$EXTZV
;LIB$FFx
;LIB$FID_TO_NAME
;LIB$FILE_SCAN
;LIB$FILE_SCAN_END

;;; <summary>
;;;
;;; </summary>
;;; <param name="filespec"></param>
;;; <param name="outspec"></param>
;;; <param name="conext"></param>
;;; <param name="defaultspec"></param>
;;; <param name="relatedspec"></param>
;;; <param name="status"></param>
;;; <param name="flags"></param>
;;; <returns></returns>
function LIB$FIND_FILE                  ,^val
    required in    filespec             ,a
    required inout outspec              ,a
.ifndef dblnet
    required inout ^ref(conext)         ,int
    optional in    defaultspec          ,a
    optional in    relatedspec          ,a
    optional out   ^ref(status)         ,int
    optional in    ^ref(flags)          ,int
.endc
proc
    throw new ApplicationException("Not implemented!")
    freturn 0
endfunction

;;; <summary>
;;;
;;; </summary>
;;; <param name="Context"></param>
;;; <returns></returns>
function LIB$FIND_FILE_END              ,^val
    required in ^ref(Context)           ,Int
proc
    throw new ApplicationException("Not implemented!")
    freturn 0
endfunction

;;; <summary>
;;;
;;; </summary>
;;; <param name="filename"></param>
;;; <param name="symbol"></param>
;;; <param name="Value"></param>
;;; <param name="imagename"></param>
;;; <param name="flags"></param>
;;; <returns></returns>
function LIB$FIND_IMAGE_SYMBOL          ,^val
    required in  filename               ,a
    required in  symbol                 ,a
    required out ^ref(Value)            ,int
    optional in  imagename              ,a
    required in  ^ref(flags)            ,int
proc
    throw new ApplicationException("Not implemented!")
    freturn 0
endfunction

;LIB$FIND_VM_ZONE
;LIB$FIND_VM_ZONE_64
;LIB$FIT_NODENAME
;LIB$FIXUP_FLT
;LIB$FLT_UNDER

;;; <summary>
;;;
;;; </summary>
;;; <param name="datetime"></param>
;;; <param name="date_in"></param>
;;; <param name="context"></param>
;;; <param name="length"></param>
;;; <param name="flags"></param>
;;; <returns></returns>
function LIB$FORMAT_DATE_TIME           ,^val
    required out   datetime             ,a
    required in    ^ref(date_in)        ,long
.ifndef dblnet
    optional inout ^ref(context)        ,int
    optional out   ^ref(length)         ,int
    optional in    ^ref(flags)          ,int
.endc
proc
    throw new ApplicationException("Not implemented!")
    freturn 0
endfunction

;LIB$FORMAT_SOGW_PROT

;;; <summary>
;;;
;;; </summary>
;;; <param name="ContextBoundObject"></param>
;;; <returns></returns>
function LIB$FREE_DATE_TIME_CONTEXT     ,^val
    required inout ^ref(ContextBoundObject),int
.include "DBLSTARLET:$SSDEF.DBL"
proc
    throw new ApplicationException("Not implemented!")
    freturn SS$_NORMAL
endfunction

;;; <summary>
;;;
;;; </summary>
;;; <param name="efkey_method"></param>
;;; <returns></returns>
function LIB$FREE_EF                    ,^val
    required in ^ref(efn)               ,int
proc
    throw new ApplicationException("Not implemented!")
    freturn 0
endfunction

;LIB$FREE_LUN
;LIB$FREE_TIMER

;;; <summary>
;;;
;;; </summary>
;;; <param name="bytecnt"></param>
;;; <param name="address"></param>
;;; <param name="zoneif"></param>
;;; <returns></returns>
function LIB$FREE_VM                    ,^val
    required in ^ref(bytecnt)           ,int
    required in ^ref(address)           ,D_ADDR
.ifndef dblnet
	optional in ^ref(zoneif)            ,int
.endc
proc
    throw new ApplicationException("Not implemented!")
    freturn 0
end

;LIB$FREE_VM_64
;LIB$FREE_VM_PAGE
;LIB$FREE_VM_PAGE_64

;;; <summary>
;;;
;;; </summary>
;;; <param name="itemcode"></param>
;;; <param name="channel"></param>
;;; <param name="devicename"></param>
;;; <param name="intvalue"></param>
;;; <param name="alpha_value"></param>
;;; <param name="resultlen"></param>
;;; <param name="pathname"></param>
;;; <returns></returns>
.ifndef dblnet
function LIB$GETDVI                     ,^val
    in           ^REF(itemcode)         ,int
    optional in  ^val(channel)          ,i
    optional in  devicename             ,a
    optional out ^ref(intvalue)         ,int
    optional out alpha_value            ,a
    optional out ^ref(resultlen)        ,short
    optional in  pathname               ,a
proc
    throw new ApplicationException("Not implemented!")
    freturn 0
endfunction
.endc

;;; <summary>
;;; 
;;; </summary>
;;; <param name="function_code"></param>
;;; <param name="item_code"></param>
;;; <param name="search_number"></param>
;;; <param name="search_name"></param>
;;; <param name="search_flags"></param>
;;; <param name="result_value"></param>
;;; <param name="result_string"></param>
;;; <param name="result_length"></param>
;;; <returns></returns>
.ifndef dblnet
function LIB$GETQUI                     ,^val
	required in  ^ref(function_code),	int
	optional in  ^ref(item_code),		int
	optional in  ^ref(search_number),	int
	optional in  search_name,			a
	optional in  ^ref(search_flags),	int
	optional out ^ref(result_value),	D_ADDR
	optional out result_string,			a
	optional out ^ref(result_length),	short
	endparams
proc
	throw new ApplicationException("Not implemented!")
	freturn 0
endfunction
.endc

;LIB$GETSYI
;LIB$GET_ACCNAM
;LIB$GET_ACCNAM_BY_CONTEXT
;LIB$GET_COMMAND
;LIB$GET_CURR_INVO_CONTEXT
;LIB$GET_DATE_FORMAT

;;; <summary>
;;;
;;; </summary>
function LIB$GET_EF                     ,^val
    required out ^ref(efn),  int
proc
    throw new ApplicationException("Not implemented!")
    freturn 0
endfunction

;LIB$GET_FULLNAME_OFFSET
;LIB$GET_HOSTNAME
;;; <summary>
function lib$get_input,^val
	req out arg,	a
	req in prompt,	a
.ifdef dblnet
	out ^ref(resultlen)	,short
.else
	opt out ^ref(resultlen)	,short
.endc
	record
	mychan,	int
	mybuf,	a16384
	myrdlen,int
proc
	clear mychan,myrdlen
	on error passback
	open(mychan,o,'tt:')
	display(mychan,prompt)
	reads(mychan,mybuf)
	myrdlen = %rdlen(mychan)
passback,
	off error
	if (mychan) close mychan
	if myrdlen then
	    arg = prompt(1,myrdlen)
	else
	    clear arg
.ifndef dblnet
	if %passed(resultlen)
.endc
		resultlen = myrdlen
	freturn 0
endfunction
;LIB$GET_INPUT
;LIB$GET_INVO_CONTEXT
;LIB$GET_INVO_HANDLE
;LIB$GET_LOGICAL
;LIB$GET_LUN
;LIB$GET_MAXIMUM_DATE_LENGTH
;LIB$GET_PREV_INVO_CONTEXT
;LIB$GET_PREV_INVO_HANDLE
;LIB$GET_UIB_INFO
;LIB$GET_USERS_LANGUAGE

;;; <summary>
;;;
;;; </summary>
;;; <param name="numberofbytes"></param>
;;; <param name="baseaddress"></param>
;;; <param name="zoneid"></param>
;;; <returns></returns>
function LIB$GET_VM                     ,^val
    required in  ^ref(numberofbytes)    ,int
    required out ^ref(baseaddress)      ,D_ADDR
.ifndef dblnet
	optional in  ^ref(zoneid)           ,int
.endc
proc
    throw new ApplicationException("Not implemented!")
    freturn 0
endfunction

;LIB$GET_VM_64
;LIB$GET_VM_PAGE
;LIB$GET_VM_PAGE_64
;LIB$I64_CREATE_INVO_CONTEXT
;LIB$I64_FREE_INVO_CONTEXT
;LIB$I64_GET_CURR_INVO_CONTEXT
;LIB$I64_GET_CURR_INVO_HANDLE
;LIB$I64_GET_FR
;LIB$I64_GET_GR
;LIB$I64_GET_INVO_CONTEXT
;LIB$I64_GET_INVO_HANDLE
;LIB$I64_GET_PREV_INVO_CONTEXT
;LIB$I64_GET_PREV_INVO_HANDLE
;LIB$I64_GET_UNWIND_HANDLER_FV
;LIB$I64_GET_UNWIND_LSDA
;LIB$I64_GET_UNWIND_OSSD
;LIB$I64_INIT_INVO_CONTEXT
;LIB$I64_IS_AST_DISPATCH_FRAME
;LIB$I64_IS_EXC_DISPATCH_FRAME
;LIB$I64_PREV_INVO_END
;LIB$I64_PUT_INVO_REGISTERS
;LIB$I64_SET_FR
;LIB$I64_SET_GR
;LIB$I64_SET_PC
;LIB$ICHAR
;LIB$INDEX

;;; <summary>
;;;
;;; </summary>
;;; <param name="Context"></param>
;;; <param name="component"></param>
;;; <param name="initstring"></param>
;;; <returns></returns>
function LIB$INIT_DATE_TIME_CONTEXT     ,^val
    required inout ^ref(Context)        ,int
    required in    ^ref(component)      ,int
    required in    initstring           ,a
proc
    throw new ApplicationException("Not implemented!")
    freturn 0
endfunction

;LIB$INIT_TIMER
;LIB$INSERT_TREE
;LIB$INSERT_TREE_64
;LIB$INSQHI
;LIB$INSQHIQ
;LIB$INSQTI
;LIB$INSQTIQ
;LIB$INSV
;LIB$INT_OVER
;LIB$LEN
;LIB$LOCC
;LIB$LOCK_IMAGE
;LIB$LOOKUP_KEY
;LIB$LOOKUP_TREE
;LIB$LOOKUP_TREE_64
;LIB$LP_LINES

;;; <summary>
;;;
;;; </summary>
;;; <param name="substring"></param>
;;; <param name="source"></param>
;;; <returns></returns>
function LIB$MATCHC                     ,^val
    required in substring               ,a
    required in source                  ,a
proc
    throw new ApplicationException("Not implemented!")
    freturn %instr(1,source,substring)
endfunction

;LIB$MATCH_COND
;LIB$MOVTUC
;LIB$MULT_DELTA_TIME
;LIB$MULTF_DELTA_TIME
;LIB$MULTS_DELTA_TIME
;LIB$PARSE_ACCESS_CODE
;LIB$PARSE_SOGW_PROT
;LIB$PAUSE
;LIB$POLYD
;LIB$POLYF
;LIB$POLYG
;LIB$POLYH
;LIB$POLYS
;LIB$POLYT
;LIB$PUT_INVO_REGISTERS
;LIB$RADIX_POINT
;LIB$REMQHI
;LIB$REMQHIQ
;LIB$REMQTI
;LIB$REMQTIQ
;LIB$RESERVE_EF
;LIB$RESET_VM_ZONE
;LIB$RESET_VM_ZONE_64
;LIB$REVERT
;LIB$RUN_PROGRAM
;LIB$SCANC
;LIB$SCOPY_DXDX
;LIB$SCOPY_R_DX
;LIB$SCOPY_R_DX_64
;LIB$SFREE1_DD
;LIB$SFREEN_DD
;LIB$SGET1_DD
;LIB$SGET1_DD_64
;LIB$SHOW_TIMER
;LIB$SHOW_VM
;LIB$SHOW_VM_64
;LIB$SHOW_VM_ZONE
;LIB$SHOW_VM_ZONE_64
;LIB$SIGNAL
;LIB$SIG_TO_RET
;LIB$SIG_TO_STOP
;LIB$SIM_TRAP
;LIB$SKPC
;LIB$SPANC
;LIB$STAT_TIMER
;LIB$STAT_VM
;LIB$STAT_VM_64
;LIB$SUBX
;LIB$SYS_ASCTIM
;LIB$SYS_FAO
;LIB$SYS_FAOL
;LIB$SYS_FAOL_64
function LIB$SYS_GETMSG,^val
	in ^ref(arg1),	int
	out ^ref(arg2),	short
	out string,	a
	in ^ref(mask),	int
proc
	throw new ApplicationException("Not implemented!")

	freturn 0
	end
;LIB$TPARSE/LIB$TABLE_PARSE
;LIB$TRAVERSE_TREE
;LIB$TRAVERSE_TREE_64
;LIB$TRA_ASC_EBC
;LIB$TRA_EBC_ASC
;LIB$TRIM_FILESPEC
;LIB$TRIM_FULLNAME
;LIB$UNLOCK_IMAGE
;LIB$VERIFY_VM_ZONE
;LIB$VERIFY_VM_ZONE_64
;LIB$WAIT

;;-----------------------------------------------------------------------------
;;Librarian (LBR$) routines (See Utility Routines Manual)

;LBR$CLOSE
;LBR$DELETE_DATA
;LBR$DELETE_KEY
;LBR$FIND
;LBR$FLUSH
;LBR$GET_HEADER
;LBR$GET_HELP
;LBR$GET_HISTORY
;LBR$GET_INDEX
;LBR$GET_RECORD
;LBR$INI_CONTROL
;LBR$INSERT_KEY
;LBR$LOOKUP_KEY
;LBR$LOOKUP_TYPE
;LBR$MAP_MODULE
;LBR$OPEN
;LBR$OUTPUT_HELP
;LBR$PUT_END
;LBR$PUT_HISTORY
;LBR$PUT_MODULE
;LBR$PUT_RECORD
;LBR$REPLACE_KEY
;LBR$RET_RMSSTV.
;LBR$SEARCH
;LBR$SET_INDEX
;LBR$SET_LOCATE
;LBR$SET_MODULE
;LBR$SET_MOVE
;LBR$UNMAP_MODULE

;;-----------------------------------------------------------------------------
;;LOGINOUT (LGI$) routines (See Utility Routines Manual)

;LGI$ICR_AUTHENTICATE
;LGI$ICR_CHKRESTRICT
;LGI$ICR_DECWINIT
;LGI$ICR_FINISH
;LGI$ICR_IACT_START
;LGI$ICR_IDENTIFY
;LGI$ICR_INIT
;LGI$ICR_JOBSTEP
;LGI$ICR_LOGOUT
;
;LOGINOUT Call-Back Routines
;
;LGI$ICB_ACCTEXPIRED
;LGI$ICB_AUTOLOGIN
;LGI$ICB_CHECK_PASS
;LGI$ICB_DISUSER
;LGI$ICB_GET_INPUT
;LGI$ICB_GET_SYSPWD
;LGI$ICB_MODALHOURS
;LGI$ICB_PASSWORD
;LGI$ICB_PWDEXPIRED
;LGI$ICB_USERPARSE
;LGI$ICB_USERPROMPT
;LGI$ICB_VALIDATE

;;-----------------------------------------------------------------------------
;;Mail Utility (MAIL$) routines (See Utility Routines Manual)

;MAIL$MAILFILE_BEGIN
;MAIL$MAILFILE_CLOSE
;MAIL$MAILFILE_COMPRESS
;MAIL$MAILFILE_END
;MAIL$MAILFILE_INFO_FILE
;MAIL$MAILFILE_MODIFY
;MAIL$MAILFILE_OPEN
;MAIL$MAILFILE_PURGE_WASTE
;MAIL$MESSAGE_BEGIN
;MAIL$MESSAGE_COPY
;MAIL$MESSAGE_DELETE
;MAIL$MESSAGE_END
;MAIL$MESSAGE_GET
;MAIL$MESSAGE_INFO
;MAIL$MESSAGE_MODIFY
;MAIL$MESSAGE_SELECT
;MAIL$SEND_ABORT
;MAIL$SEND_ADD_ADDRESS
;MAIL$SEND_ADD_ATTRIBUTE
;MAIL$SEND_ADD_BODYPART
;MAIL$SEND_BEGIN
;MAIL$SEND_END
;MAIL$SEND_MESSAGE
;MAIL$USER_BEGIN
;MAIL$USER_DELETE_INFO
;MAIL$USER_END
;MAIL$USER_GET_INFO
;MAIL$USER_SET_INFO

;;-----------------------------------------------------------------------------
;;National Character Set (NCS$) routines (See Utility Routines Manual)

;NCS$COMPARE
;NCS$CONVERT
;NCS$END_CF
;NCS$END_CS
;NCS$GET_CF
;NCS$GET_CS
;NCS$RESTORE_CF
;NCS$RESTORE_CS
;NCS$SAVE_CF
;NCS$SAVE_CS

;;-----------------------------------------------------------------------------
;; RTL General Purpose (OTS$) Routines

;OTS$CALL_PROC
;OTS$CNVOUT
;OTS$CVT_L_TB
;OTS$CVT_L_TI
;OTS$CVT_L_TL
;OTS$CVT_L_TO
;OTS$CVT_L_TU
;OTS$CVT_L_TZ
;OTS$CVT_T_x
;OTS$CVT_TB_L
;OTS$CVT_TI_L
;OTS$CVT_TL_L
;OTS$CVT_TO_L
;OTS$CVT_TU_L
;OTS$CVT_TZ_L
;OTS$DIVCx
;OTS$DIV_PK_LONG
;OTS$DIV_PK_SHORT
;OTS$JUMP_TO_BPV
;OTS$MOVE3
;OTS$MOVE5
;OTS$MULCx
;OTS$POWCxCx
;OTS$POWCxJ
;OTS$POWDD
;OTS$POWDJ
;OTS$POWDR
;OTS$POWGG
;OTS$POWGJ
;OTS$POWHH_R3
;OTS$POWHJ_R3
;OTS$POWII
;OTS$POWJJ
;OTS$POWLULU
;OTS$POWRD
;OTS$POWRJ
;OTS$POWRR
;OTS$POWSJ
;OTS$POWSS
;OTS$POWTJ
;OTS$POWTT
;OTS$POWxLU
;OTS$SCOPY_DXDX
;OTS$SCOPY_R_DX
;OTS$SFREE1_DD
;OTS$SFREEN_DD
;OTS$SGET1_DD

;;-----------------------------------------------------------------------------
;;Print Symbiont Modification (PSM$) Routines (See Utility Routines Manual)

;PSM$PRINT
;PSM$READ_ITEM_DX
;PSM$REPLACE
;PSM$REPORT
;USER-FORMAT-ROUTINE
;USER-INPUT-ROUTINE
;USER-OUTPUT-ROUTINE

;;-----------------------------------------------------------------------------
;;Symbiont/Job Controller Interface (SMB) Routines (See Utility Routines Manual)

;SMB$CHECK_FOR_MESSAGE
;SMB$INITIALIZE
;SMB$READ_MESSAGE
;SMB$READ_MESSAGE_ITEM
;SMB$SEND_TO_JOBCTL

;;-----------------------------------------------------------------------------
;; Screen Management (SMG$) Routines

;SMG$ADD_KEY_DEF
;SMG$BEGIN_DISPLAY_UPDATE
;SMG$BEGIN_PASTEBOARD_UPDATE
;SMG$CANCEL_INPUT
;SMG$CHANGE_PBD_CHARACTERISTICS
;SMG$CHANGE_RENDITION
;SMG$CHANGE_VIEWPORT
;SMG$CHANGE_VIRTUAL_DISPLAY
;SMG$CHECK_FOR_OCCLUSION
;SMG$CONTROL_MODE
;SMG$COPY_VIRTUAL_DISPLAY
;SMG$CREATE_KEY_TABLE
;SMG$CREATE_MENU
;SMG$CREATE_PASTEBOARD
;SMG$CREATE_SUBPROCESS
;SMG$CREATE_VIEWPORT
;SMG$CREATE_VIRTUAL_DISPLAY
;SMG$CREATE_VIRTUAL_KEYBOARD
;SMG$CURSOR_COLUMN
;SMG$CURSOR_ROW
;SMG$DEFINE_KEY
;SMG$DELETE_CHARS
;SMG$DELETE_KEY_DEF
;SMG$DELETE_LINE
;SMG$DELETE_MENU
;SMG$DELETE_PASTEBOARD
;SMG$DELETE_SUBPROCESS
;SMG$DELETE_VIEWPORT
;SMG$DELETE_VIRTUAL_DISPLAY
;SMG$DELETE_VIRTUAL_KEYBOARD
;SMG$DEL_TERM_TABLE
;SMG$DISABLE_BROADCAST_TRAPPING
;SMG$DISABLE_UNSOLICITED_INPUT
;SMG$DRAW_CHAR
;SMG$DRAW_LINE
;SMG$DRAW_RECTANGLE
;SMG$ENABLE_UNSOLICITED_INPUT
;SMG$END_DISPLAY_UPDATE
;SMG$END_PASTEBOARD_UPDATE
;SMG$ERASE_CHARS
;SMG$ERASE_COLUMN
;SMG$ERASE_DISPLAY
;SMG$ERASE_LINE
;SMG$ERASE_PASTEBOARD
;SMG$EXECUTE_COMMAND
;SMG$FIND_CURSOR_DISPLAY
;SMG$FLUSH_BUFFER
;SMG$FLUSH_DISPLAY_UPDATE
;SMG$GET_BROADCAST_MESSAGE
;SMG$GET_CHAR_AT_PHYSICAL_CURSOR
;SMG$GET_DISPLAY_ATTR
;SMG$GET_KEYBOARD_ATTRIBUTES
;SMG$GET_KEY_DEF
;SMG$GET_NUMERIC_DATA
;SMG$GET_PASTEBOARD_ATTRIBUTES
;SMG$GET_PASTING_INFO
;SMG$GET_TERM_DATA
;SMG$GET_VIEWPORT_CHAR
;SMG$HOME_CURSOR
;SMG$INIT_TERM_TABLE
;SMG$INIT_TERM_TABLE_BY_TYPE
;SMG$INSERT_CHARS
;SMG$INSERT_LINE
;SMG$INVALIDATE_DISPLAY
;SMG$KEYCODE_TO_NAME
;SMG$LABEL_BORDER
;SMG$LIST_KEY_DEFS
;SMG$LIST_PASTEBOARD_ORDER
;SMG$LIST_PASTING_ORDER
;SMG$LOAD_KEY_DEFS
;SMG$LOAD_VIRTUAL_DISPLAY
;SMG$MOVE_TEXT
;SMG$MOVE_VIRTUAL_DISPLAY
;SMG$NAME_TO_KEYCODE
;SMG$PASTE_VIRTUAL_DISPLAY
;SMG$POP_VIRTUAL_DISPLAY
;SMG$PRINT_PASTEBOARD
;SMG$PUT_CHARS
;SMG$PUT_CHARS_HIGHWIDE
;SMG$PUT_CHARS_MULTI
;SMG$PUT_CHARS_WIDE
;SMG$PUT_HELP_TEXT
;SMG$PUT_LINE
;SMG$PUT_LINE_HIGHWIDE
;SMG$PUT_LINE_MULTI
;SMG$PUT_LINE_WIDE
;SMG$PUT_PASTEBOARD
;SMG$PUT_STATUS_LINE
;SMG$READ_COMPOSED_LINE
;SMG$READ_FROM_DISPLAY
;SMG$READ_KEYSTROKE
;SMG$READ_LOCATOR
;SMG$READ_STRING
;SMG$READ_VERIFY
;SMG$REMOVE_LINE
;SMG$REPAINT_LINE
;SMG$REPAINT_SCREEN
;SMG$REPASTE_VIRTUAL_DISPLAY
;SMG$REPLACE_INPUT_LINE
;SMG$RESTORE_PHYSICAL_SCREEN
;SMG$RETURN_CURSOR_POS
;SMG$RETURN_INPUT_LINE
;SMG$RING_BELL
;SMG$SAVE_PHYSICAL_SCREEN
;SMG$SAVE_VIRTUAL_DISPLAY
;SMG$SCROLL_DISPLAY_AREA
;SMG$SCROLL_VIEWPORT
;SMG$SELECT_FROM_MENU
;SMG$SET_BROADCAST_TRAPPING
;SMG$SET_CURSOR_ABS
;SMG$SET_CURSOR_MODE
;SMG$SET_CURSOR_REL
;SMG$SET_DEFAULT_STATE
;SMG$SET_DISPLAY_SCROLL_REGION
;SMG$SET_KEYPAD_MODE
;SMG$SET_OUT_OF_BAND_ASTS
;SMG$SET_PHYSICAL_CURSOR
;SMG$SET_TERM_CHARACTERISTICS
;SMG$SNAPSHOT
;SMG$SNAPSHOT_TO_PRINTER
;SMG$UNPASTE_VIRTUAL_DISPLAY

;;-----------------------------------------------------------------------------
;;Sort/Merge (SOR$) Routines (See Utility Routines Manual)

;SOR$BEGIN_MERGE
;SOR$BEGIN_SORT
;SOR$DTYPE
;SOR$END_SORT
;SOR$PASS_FILES
;SOR$RELEASE_REC
;SOR$RETURN_REC
;SOR$SORT_MERGE
;SOR$SPEC_FILE
;SOR$STAT

;;-----------------------------------------------------------------------------
;; String Manipulation (STR$) Routines

;STR$ADD
;STR$ANALYZE_SDESC
;STR$ANALYZE_SDESC_64
;STR$APPEND
;STR$CASE_BLIND_COMPARE
;STR$COMPARE.
;STR$COMPARE_EQL
;STR$COMPARE_MULTI
;STR$COPY_DX
;STR$COPY_R
;STR$COPY_R_64
;STR$DIVIDE

;;; <summary>
;;;
;;; </summary>
;;; <param name="source"></param>
;;; <param name="setofchars"></param>
;;; <returns></returns>
function STR$FIND_FIRST_IN_SET          ,^val
    required in source                  ,a
    required in setofchars              ,a
proc
    throw new ApplicationException("Not implemented!")
    freturn 0
endfunction

;STR$FIND_FIRST_SUBSTRING
;STR$FREE1_DX
;STR$GET1_DX
;STR$GET1_DX_64
;STR$LEFT
;STR$LEN_EXTR
;STR$MUL
;STR$POSITION
;STR$POS_EXTR
;STR$PREFIX
;STR$RECIP
;STR$REPLACE
;STR$RIGHT
;STR$ROUND

;;-----------------------------------------------------------------------------
;; SYS$ routines

;SYS$ABORT_TRANS
;SYS$ABORT_TRANSW
;SYS$ACK_EVENT
;SYS$ACM
;SYS$ACMW
;SYS$ACQUIRE_GALAXY_LOCK
;SYS$ADD_BRANCH
;SYS$ADD_BRANCHW
;SYS$ADD_HOLDER
;SYS$ADD_IDENT
;SYS$ADD_PROXY
;SYS$ADJSTK

;;; <summary>
;;;
;;; </summary>
;;; <param name="pagecnt"></param>
;;; <param name="wsl"></param>
;;; <returns></returns>
.ifndef dblnet
function SYS$ADJWSL                     ,^val
    optional in  ^val(pagecnt)          ,i
    optional out ^ref(wsl)              ,int
	.include "DBLSTARLET:$SSDEF.DBL"
proc
	; just a NOP outside VMS
    freturn SS$_NORMAL
endfunction
.endc
;;; <summary>
;;;
;;; </summary>
;;; <param name="name"></param>
;;; <param name="outlen"></param>
;;; <param name="physicaldevname"></param>
;;; <param name="acmode"></param>
;;; <param name="flags"></param>
;;; <returns></returns>
.ifndef dblnet
function SYS$ALLOC                      ,^val
    required in  name                   ,a
    optional out ^ref(outlen)           ,short
    optional out physicaldevname        ,a
    optional in  ^val(acmode)           ,i
    optional in  ^val(flags)            ,i
proc
    throw new ApplicationException("Not implemented!")
    freturn 0
endfunction
.endc
;SYS$ASCEFC
;SYS$ASCTOID
;SYS$ASCUTC
;SYS$AUDIT_EVENT
;SYS$AUDIT_EVENTW
;SYS$AVOID_PREEMPT
;SYS$BINUTC

;;; <summary>
;;; Not documented in system services reference manual?
;;; </summary>

function SYS$BRDCST                     ,^val
	arg1,a			;message
	arg2,a			; operator eg opa0:
proc
.if ^defined(DBLNET) && !^defined(DBLV125)
	throw new ApplicationException("Not implemented!")
.else
    xcall syn_reportevent(D_EVENTLOG_INFORMATION_TYPE,arg1)
.endc
	freturn 0
endfunction

;;; <summary>
;;;
;;; </summary>
;;; <param name="ef_number"></param>
;;; <param name="messagebuf"></param>
;;; <param name="sendto"></param>
;;; <param name="sendtype"></param>
;;; <param name="iosb"></param>
;;; <param name="carcon"></param>
;;; <param name="flags"></param>
;;; <param name="reqid"></param>
;;; <param name="Timeout"></param>
;;; <param name="astadr"></param>
;;; <param name="astparm"></param>
;;; <returns></returns>
.ifndef dblnet
function SYS$BRKTHRU                    ,^val
    opt in  ^val(ef_number)        ,i
    required in  messagebuf             ,a
    optional in  sendto                 ,a
    optional     ^val(sendtype)         ,i
    optional out ^ref(iosb)             ,int
    optional     ^val(carcon)           ,i
    optional     ^val(flags)            ,i
    optional     ^val(reqid)            ,i
    optional     ^val(Timeout)          ,i
    optional     ^val(astadr)           ,D_ADDR
    optional     ^val(astparm)          ,i
proc
    throw new ApplicationException("Not implemented!")
    freturn 0
endfunction
.endc
;;; <summary>
;;;
;;; </summary>
;;; <param name="ef_number"></param>
;;; <param name="messagebuf"></param>
;;; <param name="sendto"></param>
;;; <param name="sendtype"></param>
;;; <param name="iosb"></param>
;;; <param name="carcon"></param>
;;; <param name="flags"></param>
;;; <param name="reqid"></param>
;;; <param name="Timeout"></param>
;;; <param name="astadr"></param>
;;; <param name="astparm"></param>
;;; <returns></returns>
.ifndef dblnet
function SYS$BRKTHRUW                   ,^val
    required in  ^val(ef_number)        ,i
    required in  messagebuf             ,a
    optional in  sendto                 ,a
    optional     ^val(sendtype)         ,i
    optional out ^ref(iosb)             ,int
    optional     ^val(carcon)           ,i
    optional     ^val(flags)            ,i
    optional     ^val(reqid)            ,i
    optional     ^val(Timeout)          ,i
    optional     ^val(astadr)           ,D_ADDR
    optional     ^val(astparm)          ,i
proc
    throw new ApplicationException("Not implemented!")
    freturn 0
endfunction
.endc

;;; <summary>
;;;
;;; </summary>
;;; <param name="channel"></param>
;;; <returns></returns>
function SYS$CANCEL                     ,^val
    required in ^val(channel)           ,i
proc
    throw new ApplicationException("Not implemented!")
    freturn 0
endfunction

;SYS$CANEXH

;;; <summary>
;;;
;;; </summary>
;;; <param name="reqidt"></param>
;;; <param name="accmode"></param>
;;; <returns></returns>
function SYS$CANTIM                     ,^val
    default in ^val(reqidt)            ,int,0
    default in ^val(accmode)           ,int,0
proc
    throw new ApplicationException("Not implemented!")
    freturn 0
endfunction

;SYS$CANWAK
;SYS$CHECK_ACCESS
;SYS$CHECK_FEN
;SYS$CHECK_PRIVILEGE
;SYS$CHECK_PRIVILEGEW
;SYS$CHKPRO
;SYS$CLEAR_SYSTEM_EVENT
;SYS$CLEAR_UNWIND_TABLE
;SYS$CLOSE
;SYS$CLRAST
;SYS$CLRCLUEVT

;;; <summary>
;;;
;;; </summary>
;;; <param name="ef_number"></param>
;;; <returns></returns>
function SYS$CLREF                      ,^val
    required in ^val(ef_number)         ,i
proc
    throw new ApplicationException("Not implemented!")
    freturn 0
endfunction

;;;
;;; </summary>
;;; <param name="procmask"></param>
;;; <param name="arglist"></param>
;;; <returns></returns>
function SYS$CMEXEC                     ,^val
    required in ^val(procmask)          ,i
    required in ^ref(arglist)           ,int
proc
    throw new ApplicationException("Not implemented!")
    freturn 0
endfunction

;SYS$CMEXEC_64
;SYS$CMKRNL
;SYS$CMKRNL_64
;SYS$CONNECT
;SYS$CPU_CAPABILITIES
;SYS$CPU_TRANSITION
;SYS$CPU_TRANSITIONW
;SYS$CREATE
;SYS$CREATE_BUFOBJ_64
;SYS$CREATE_GALAXY_LOCK
;SYS$CREATE_GALAXY_LOCK_TABLE
;SYS$CREATE_GDZRO
;SYS$CREATE_GFILE
;SYS$CREATE_GPFILE
;SYS$CREATE_GPFN
;SYS$CREATE_RDB
;SYS$CREATE_REGION_64
;;;
;;; </summary>
;;; <param name="uid"></param>
;;; <returns></returns>
.ifndef dblnet
function SYS$CREATE_UID, ^VAL
	req out ^ref(uid),	[#]int
proc
	throw new ApplicationException("Not implemented!")
	freturn 0
endfunction
.endc
;SYS$CREATE_USER_PROFILE

;;; <summary>
;;;
;;; </summary>
;;; <param name="Attr"></param>
;;; <param name="tablename"></param>
;;; <param name="logicalname"></param>
;;; <param name="access_mode"></param>
;;; <param name="itemlist"></param>
;;; <returns></returns>
.ifndef dblnet
function SYS$CRELNM                     ,^val
    optional in ^ref(Attr)              ,int
    required in tablename               ,a
    required in logicalname             ,a
    optional in ^ref(access_mode)       ,byte
    optional in ^ref(itemlist)          ,item_list
proc
	; if ever implmented only a single item is allowed not a arraylist
    throw new ApplicationException("Not implemented!")
    freturn 0
endfunction
.endc
;SYS$CRELNT

;;; <summary>
;;;
;;; </summary>
;;; <param name="prmflg"></param>
;;; <param name="chan"></param>
;;; <param name="maxmsg"></param>
;;; <param name="bufquo"></param>
;;; <param name="promsk"></param>
;;; <param name="access_mode"></param>
;;; <param name="logicalname"></param>
;;; <param name="flags"></param>
;;; <param name="unused"></param>
;;; <returns></returns>
.ifndef dblnet
function SYS$CREMBX                     ,^val
    optional in  ^val(prmflg)           ,i
    required out ^ref(chan)             ,short
    optional in  ^val(maxmsg)           ,i
    optional in  ^val(bufquo)           ,i
    optional in  ^val(promsk)           ,i
    optional in  ^val(access_mode)      ,i
    optional in  logicalname            ,a
    optional in  ^val(flags)            ,i
    optional in  ^val(unused)           ,i
proc
    throw new ApplicationException("Not implemented!")
    freturn 0
endfunction
.endc
;;; <summary>
;;;
;;; </summary>
;;; <param name="pidaddr"></param>
;;; <param name="imagename"></param>
;;; <param name="sysinput"></param>
;;; <param name="sysoutput"></param>
;;; <param name="syserror"></param>
;;; <param name="privs"></param>
;;; <param name="quota"></param>
;;; <param name="processname"></param>
;;; <param name="basepri"></param>
;;; <param name="uic"></param>
;;; <param name="mbxunit"></param>
;;; <param name="mask"></param>
;;; <returns></returns>
function SYS$CREPRC                     ,^val
.ifdef dblnet
    out ^ref(pidaddr)			,D_ADDR
.else
    optional out ^ref(pidaddr)          ,D_ADDR
.endc
    optional in  imagename              ,a
    optional in  sysinput               ,a
    optional in  sysoutput              ,a
    optional in  syserror               ,a
.ifndef dblnet
    optional in  ^ref(privs)            ,int
    optional in  ^ref(quota)            ,int
    optional in  processname            ,a
    optional in  ^val(basepri)          ,i
    optional in  ^val(uic)              ,i
    optional in  ^val(mbxunit)          ,i
    optional in  ^val(mask)             ,i
.endc
proc
    throw new ApplicationException("Not implemented!")
    freturn 0
endfunction

;SYS$CRETVA
;SYS$CRETVA_64
;SYS$CRMPSC
;SYS$CRMPSC_FILE_64
;SYS$CRMPSC_GDZRO_64
;SYS$CRMPSC_GFILE_64
;SYS$CRMPSC_GPFILE_64
;SYS$CRMPSC_GPFN_64
;SYS$CRMPSC_PFN_64
;SYS$CVT_FILENAME
;SYS$DACEFC

;;; <summary>
;;;
;;; </summary>
;;; <param name="devname"></param>
;;; <param name="access_mode"></param>
;;; <returns></returns>
.ifndef dblnet
function SYS$DALLOC                     ,^val
    optional in devname                 ,a
    optional in ^val(access_mode)       ,i
proc
    throw new ApplicationException("Not implemented!")
    freturn 0
endfunction
.endc
;;; <summary>
;;;
;;; </summary>
;;; <param name="channel"></param>
;;; <returns></returns>
function SYS$DASSGN                     ,^val
    required in ^val(channel)           ,i
proc
    throw new ApplicationException("Not implemented!")
    freturn 0
endfunction

;SYS$DCLAST
;SYS$DCLCMH
;SYS$DCLEXH
;SYS$DECLARE_RM
;SYS$DECLARE_RMW
;SYS$DELETE
;SYS$DELETE_BUFOBJ
;SYS$DELETE_GALAXY_LOCK
;SYS$DELETE_GALAXY_LOCK_TABLE
;SYS$DELETE_INTRUSION
;SYS$DELETE_PROXY
;SYS$DELETE_REGION_64

;;; <summary>
;;;
;;; </summary>
;;; <param name="tablename"></param>
;;; <param name="logicalname"></param>
;;; <param name="access_mode"></param>
;;; <returns></returns>
function SYS$DELLNM                     ,^val
    required in tablename               ,a
    optional in logicalname             ,a
.ifndef dblnet
	optional in ^ref(access_mode)       ,byte
.endc
proc
    throw new ApplicationException("Not implemented!")
    freturn 0
endfunction

;SYS$DELMBX

;;; <summary>
;;;
;;; </summary>
;;; <param name="PID"></param>
;;; <param name="processname"></param>
;;; <param name="flags"></param>
;;; <returns></returns>
.ifndef dblnet
function SYS$DELPRC                     ,^val
    optional inout ^ref(PID)            ,int
    optional in    processname          ,a
    optional       ^val(flags)          ,i
proc
    throw new ApplicationException("Not implemented!")
    freturn 0
endfunction
.endc
;SYS$DELTVA
;SYS$DELTVA_64
;SYS$DEQ
;SYS$DEVICE_PATH_SCAN
;SYS$DEVICE_SCAN
;SYS$DGBLSC
;SYS$DISCONNECT
;SYS$DISMOU
;SYS$DISPLAY
;SYS$DISPLAY_PROXY
;SYS$DLCEFC
;SYS$END_BRANCH
;SYS$END_BRANCHW
;SYS$END_TRANS
;SYS$END_TRANSW
;SYS$ENQ
;SYS$ENQW
;SYS$ENTER
;SYS$ERAPAT
;SYS$ERASE
;SYS$EXIT
;SYS$EXPREG
;SYS$EXPREG_64
;SYS$EXTEND

;;; <summary>
;;;
;;; </summary>
;;; <param name="ctstr"></param>
;;; <param name="outlen"></param>
;;; <param name="outbuf"></param>
;;; <returns></returns>
.ifndef dblnet
function SYS$FAO                        ,^val, varargs
    required in  ctstr                  ,a
    optional out ^ref(outlen)           ,short
    required out outbuf                 ,a
proc
    throw new ApplicationException("Not implemented!")
    freturn 0
endfunction
.endc
;SYS$FAOL
;SYS$FAOL_64

;;; <summary>
;;;
;;; </summary>
;;; <param name="srcstr"></param>
;;; <param name="itemlist"></param>
;;; <param name="flags"></param>
;;; <param name="auxout"></param>
;;; <param name="retlen"></param>
;;; <returns></returns>
function SYS$FILESCAN                   ,^val
    required in    srcstr               ,a
    required inout ^ref(itemlist)       ,item_list
.ifndef dblnet
    optional out   ^ref(flags)          ,int
    optional out   auxout               ,a
    optional out   ^ref(retlen)         ,short
.endc
proc
	; if ever implmented only a single item is allowed not a arraylist
    throw new ApplicationException("Not implemented!")
    freturn 0
endfunction

;SYS$FIND

;;; <summary>
;;; 
;;; </summary>
;;; <param name="holder"></param>
;;; <param name="rightsid"></param>
;;; <param name="attrib"></param>
;;; <param name="context"></param>
;;; <returns></returns>
.ifndef dblnet
function SYS$FIND_HELD                  ,^val
	required in ^ref(holder)	,long
	optional out ^ref(rightsid)	,int
	optional out ^ref(attrib)	,int
	optional inout ^ref(context)	,int
proc
	throw new ApplicationException("Not implemented!")
	freturn 0
endfunction
.endc
;SYS$FIND_HOLDER

;;; <summary>
;;; 
;;; </summary>
;;; <param name="context"></param>
;;; <returns></returns>
function SYS$FINISH_RDB			,^val
	required inout ^ref(context)	,int
proc
	throw new ApplicationException("Not implemented!")
	freturn 0
endfunction

;SYS$FLUSH

;;; <summary>
;;;
;;; </summary>
;;; <param name="PID"></param>
;;; <param name="processname"></param>
;;; <param name="code"></param>
;;; <returns></returns>
.ifndef dblnet
function SYS$FORCEX                     ,^val
    optional in ^ref(PID)               ,int
    optional in processname             ,a
    optional in ^val(code)              ,i
proc
    throw new ApplicationException("Not implemented!")
    freturn 0
endfunction
.endc
;SYS$FORGET_RM
;SYS$FORGET_RMW
;SYS$FORMAT_ACL
;SYS$FORMAT_AUDIT
;SYS$FREE
;SYS$FREE_USER_CAPABILITY
;SYS$GET
;SYS$GETDTI
;SYS$GETDTIW

;;; <summary>
;;;
;;; </summary>
;;; <param name="EFN"></param>
;;; <param name="channel"></param>
;;; <param name="devicename"></param>
;;; <param name="itemlist"></param>
;;; <param name="iosb"></param>
;;; <param name="astadr"></param>
;;; <param name="astparm"></param>
;;; <param name="nullarg"></param>
;;; <param name="path_name"></param>
;;; <returns></returns>
function SYS$GETDVI                     ,^val
.ifdef dblnet
    in  ^val(EFN)              ,i		; just pass 0
    in  ^val(channel)          ,i		;just pass 0
.else
    default  in  ^val(EFN)              ,i
    default  in  ^val(channel)          ,i
.endc
    optional in  devicename             ,a
    required in  ^ref(itemlist)         ,item_list
.ifndef dblnet
    optional out ^ref(iosb)             ,int
    optional     ^val(astadr)           ,i
    optional     ^val(astparm)          ,D_ADDR
    optional     ^ref(nullarg)          ,long
    optional in  path_name              ,a
.endc
proc
   freturn %sys$getdviw(efn,channel,devicename,^ref(itemlist))

endfunction

;;; <summary>
;;;
;;; </summary>
;;; <param name="EFN"></param>
;;; <param name="channel"></param>
;;; <param name="devicename"></param>
;;; <param name="itemlist"></param>
;;; <param name="iosb"></param>
;;; <param name="astadr"></param>
;;; <param name="astparm"></param>
;;; <param name="nullarg"></param>
;;; <param name="path_name"></param>
;;; <returns></returns>
function SYS$GETDVIW                    ,^val
.ifdef dblnet
    in ^val(EFN)               ,i			; just pass 0
    in ^val(channel)           ,i			; just pass 0
.else
    default  in ^val(EFN)               ,i,0
    default  in ^val(channel)           ,i,0
.endc
    optional in devicename              ,a
    required in  ^ref(itemlist)         ,item_list
.ifndef dblnet
    optional out ^ref(iosb)             ,int
    optional     ^val(astadr)           ,D_ADDR
    optional     ^val(astparm)          ,i
    optional     ^ref(nullarg)          ,long
    optional in  path_name              ,a
.endc
proc
	; if ever implmented only a single item is allowed not a arraylist
    throw new ApplicationException("Not implemented!")
    freturn 0
endfunction

;SYS$GETENV
;SYS$GET_GALAXY_LOCK_INFO
;SYS$GET_GALAXY_LOCK_SIZE

;;; <summary>
;;;
;;; </summary>
;;; <param name="EFN"></param>
;;; <param name="process_id"></param>
;;; <param name="process_name"></param>
;;; <param name="itemlist"></param>
;;; <param name="iosb"></param>
;;; <param name="astadr"></param>
;;; <param name="astparm"></param>
;;; <returns></returns>
function SYS$GETJPI                     ,^val
.ifdef dblnet
    in    ^val(EFN)            ,i
    inout ^ref(process_id)     ,int
.else
    optional in    ^val(EFN)            ,i
    optional inout ^ref(process_id)     ,int
.endc
    optional in    process_name         ,a
    required in    ^ref(itemlist)       ,item_list
.ifndef dblnet
    optional out   ^ref(iosb)           ,int
    optional       ^val(astadr)         ,D_ADDR
    optional       ^val(astparm)        ,i
.endc
proc
    freturn %sys$getjpiw(efn,^ref(process_id),process_name,^ref(itemlist))
endfunction

;;; <summary>
;;;
;;; </summary>
;;; <param name="EFN"></param>
;;; <param name="process_id"></param>
;;; <param name="process_name"></param>
;;; <param name="itemlist"></param>
;;; <param name="iosb"></param>
;;; <param name="astadr"></param>
;;; <param name="astparm"></param>
;;; <returns></returns>
function SYS$GETJPIW                    ,^val
.ifdef dblnet
    in    ^val(EFN)            ,i		; just pass 0
    inout ^ref(process_id)     ,int
.else
    optional in    ^val(EFN)            ,i
    optional inout ^ref(process_id)     ,int
.endc
    optional in    process_name         ,a
    required in    ^ref(itemlist)       ,item_list
.ifndef dblnet
    optional out   ^ref(iosb)           ,int
    optional       ^val(astadr)         ,D_ADDR
    optional       ^val(astparm)        ,i
.endc
proc
	; if ever implmented only a single item is allowed not a arraylist
	; use lib$getjpi instead
    throw new ApplicationException("Not implemented!")
    freturn 0
endfunction

;SYS$GETLKI
;SYS$GETLKIW

;;; <summary>
;;;
;;; </summary>
;;; <param name="msgid"></param>
;;; <param name="msglen"></param>
;;; <param name="buffer"></param>
;;; <param name="flags"></param>
;;; <param name="outadr"></param>
;;; <returns></returns>
function SYS$GETMSG                     ,^val
    required in  ^val(msgid)            ,i
    required out ^ref(msglen)           ,short
    required out buffer                 ,a
.ifdef dblnet
    in  ^val(flags)            ,i			; just pass 0
.else
    optional in  ^val(flags)            ,i
    optional out ^ref(outadr)           ,D_ADDR
.endc
proc
    throw new ApplicationException("Not implemented!")
    freturn 0
endfunction

;SYS$GETQUI

;;; <summary>
;;;
;;; </summary>
;;; <param name="efn"></param>
;;; <param name="func"></param>
;;; <param name="conext"></param>
;;; <param name="itemlist"></param>
;;; <param name="iosb"></param>
;;; <param name="astadr"></param>
;;; <param name="astparm"></param>
;;; <returns></returns>
.ifndef dblnet
function SYS$GETQUIW                    ,^val
    optional in    ^val(efn)            ,i
    required in    ^val(func)           ,i
    optional inout ^ref(conext)         ,int
    optional in    ^ref(itemlist)       ,item_list
    optional out   ^ref(iosb)           ,int
    optional       ^val(astadr)         ,D_ADDR
    optional       ^val(astparm)        ,i
proc
	; if ever implmented only a single item is allowed not a arraylist
    throw new ApplicationException("Not implemented!")
    freturn 0
endfunction
.endc
;SYS$GETRMI

;;; <summary>
;;;
;;; </summary>
function SYS$GETSYI                     ,^val
.ifdef dblnet
    in    ^val(efn)			,i
    inout ^ref(csidar)			,int
    optional in    process_name         ,a
    required in    ^ref(itemlist)       ,item_list
.else
    optional  in    ^val(efn)            ,i
    optional inout ^ref(csidar)         ,int
    optional in    process_name         ,a
    required in    ^ref(itemlist)       ,item_list
    optional out   ^ref(iosb)           ,int
    optional       ^val(astadr)         ,D_ADDR
    optional       ^val(astparm)        ,i
.endc
proc
   freturn %sys$getsyiw(efn,^ref(csidar),process_name,^ref(itemlist))
endfunction

;;; <summary>
;;;
;;; </summary>
;;; <param name="efn"></param>
;;; <param name="csidar"></param>
;;; <param name="process_name"></param>
;;; <param name="itemlist"></param>
;;; <param name="iosb"></param>
;;; <param name="astadr"></param>
;;; <param name="astparm"></param>
;;; <returns></returns>

function SYS$GETSYIW                    ,^val
.ifdef dblnet
    in ^val(efn)			,i
    inout ^ref(csidar)			,int
.else
    optional in ^val(efn)               ,i
    optional inout ^ref(csidar)         ,int
.endc
    optional in process_name            ,a
    required in  ^ref(itemlist)         ,item_list
.ifndef dblnet
    optional out ^ref(iosb)             ,int
    optional ^val(astadr)               ,D_ADDR
    optional ^val(astparm)              ,i
.endc
proc
	; if ever implmented only a single item is allowed not a arraylist
    throw new ApplicationException("Not implemented!")
    freturn 0
endfunction

;SYS$GETTIM
;SYS$GETTIM_PREC

;;; <summary>
;;;
;;; </summary>
;;; <param name="unused"></param>
;;; <param name="conext"></param>
;;; <param name="username"></param>
;;; <param name="itemlist"></param>
;;; <returns></returns>
.ifndef dblnet
function SYS$GETUAI                     ,^val
    optional in    ^val(unused)         ,i
    optional inout ^ref(conext)         ,int
    required in    username             ,a
    required in    ^ref(itemlist)       ,item_list
proc
	; if ever implmented only a single item is allowed not a arraylist
    throw new ApplicationException("Not implemented!")
    freturn 0
endfunction
.endc
;SYS$GETUTC
;SYS$GET_ALIGN_FAULT_DATA
;SYS$GET_ARITH_EXCEPTION
;SYS$GET_DEFAULT_TRANS
;SYS$GET_GALAXY_LOCK_INFO
;SYS$GET_GALAXY_LOCK_SIZE
;SYS$GET_REGION_INFO
;SYS$GET_SECURITY
;SYS$GET_SYS_ALIGN_FAULT_DATA
;SYS$GET_UNWIND_ENTRY_INFO
;SYS$GET_USER_CAPABILITY
;SYS$GOTO_UNWIND
;SYS$GOTO_UNWIND_64

;;; <summary>
;;; 
;;; </summary>
;;; <param name="pidaddr"></param>
;;; <param name="processname"></param>
;;; <param name="rightsid"></param>
;;; <param name="name"></param>
;;; <param name="prevattrib"></param>
;;; <returns></returns>
.ifndef dblnet
function SYS$GRANTID			,^val
	optional inout ^ref(pidaddr)	,D_ADDR
	optional in processname         ,a
	optional inout ^ref(rightsid)	,long
	optional in name		,a
	optional out ^ref(prevattrib)	,int
proc
	throw new ApplicationException("Not implemented!")
	freturn 0
endfunction
.endc
;;; <summary>
;;; 
;;; </summary>
;;; <param name="pwd"></param>
;;; <param name="algorithm"></param>
;;; <param name="salt"></param>
;;; <param name="usrnam"></param>
;;; <param name="hash"></param>
;;; <returns></returns>
function SYS$HASH_PASSWORD		,^val
	required in pwd			,a
	required in algorithm		,i1
	optional in salt		,i2
	required in usrnam		,a
	required out ^ref(hash)		,long
proc
	throw new ApplicationException("Not implemented!")
	freturn 0
endfunction

;SYS$HIBER
;SYS$ICC_ACCEPT
;SYS$ICC_CLOSE_ASSOC
;SYS$ICC_CONNECT
;SYS$ICC_CONNECTW
;SYS$ICC_DISCONNECT
;SYS$ICC_DISCONNECTW
;SYS$ICC_OPEN_ASSOC
;SYS$ICC_RECEIVE
;SYS$ICC_RECEIVEW
;SYS$ICC_REJECT
;SYS$ICC_REPLY
;SYS$ICC_REPLYW
;SYS$ICC_TRANSCEIVE
;SYS$ICC_TRANSCEIVEW
;SYS$ICC_TRANSMIT
;SYS$ICC_TRANSMITW

;;; <summary>
;;;
;;; </summary>
;;; <param name="id"></param>
;;; <param name="namlen"></param>
;;; <param name="namstring"></param>
;;; <param name="rightsid"></param>
;;; <param name="attrib"></param>
;;; <param name="Context"></param>
;;; <returns></returns>
.ifndef dblnet
function SYS$IDTOASC                    ,^val
    required in    ^val(id)             ,i
    optional out   ^ref(namlen)         ,short
    optional out   namstring            ,a
    optional out   ^ref(rightsid)       ,int
    optional out   ^ref(attrib)         ,int
    optional inout ^ref(Context)        ,int
proc
    throw new ApplicationException("Not implemented!")
    freturn 0
endfunction
.endc
;SYS$IEEE_SET_FP_CONTROL
;SYS$IEEE_SET_PRECISION_MODE
;SYS$IEEE_SET_ROUNDING_MODE
;SYS$INIT_SYS_ALIGN_FAULT_REPORT
;SYS$INIT_VOL
;SYS$IO_CLEANUP
;SYS$IO_FASTPATH
;SYS$IO_FASTPATHW
;SYS$IO_PERFORM
;SYS$IO_PERFORMW
;SYS$IO_SETUP
;SYS$JOIN_RM
;SYS$JOIN_RMW
;SYS$LCKPAG
;SYS$LCKPAG_64
;SYS$LKWSET
;SYS$LKWSET_64
;SYS$MGBLSC
;SYS$MGBLSC_64
;SYS$MGBLSC_GPFN_64
;SYS$MOD_HOLDER
;SYS$MOD_IDENT
;SYS$MOUNT
;SYS$MTACCESS

;;; <summary>
;;;
;;; </summary>
;;; <param name="numbuf"></param>
;;; <param name="time"></param>
;;; <returns></returns>
.ifndef dblnet
function SYS$NUMTIM                     ,^val
    required out ^ref(numbuf)           ,[*]short
    required in  ^ref(time)             ,long
proc
    throw new ApplicationException("Not implemented!")
    freturn 0
endfunction
.endc
;SYS$NUMUTC
;SYS$NXTVOL
;SYS$OPEN

;;; <summary>
;;;
;;; </summary>
;;; <param name="fab"></param>
;;; <param name="erradr"></param>
;;; <param name="sucessadr"></param>
;;; <returns></returns>

function SYS$PARSE                      ,^val
    required in ^ref(fab)               ,FABDEF
    default ^val(erradr)            ,D_ADDR,0
    default ^val(sucessadr)         ,D_ADDR,0
proc
    throw new ApplicationException("Not implemented!")
    freturn 0
endfunction

;SYS$PARSE_ACL
;SYS$PERM_DIS_ALIGN_FAULT_REPORT
;SYS$PERM_REPORT_ALIGN_FAULT
;SYS$PERSONA_ASSUME
;SYS$PERSONA_CLONE
;SYS$PERSONA_CREATE
;SYS$PERSONA_CREATE_EXTENSION
;SYS$PERSONA_DELEGATE
;SYS$PERSONA_DELETE
;SYS$PERSONA_DELETE_EXTENSION
;SYS$PERSONA_EXTENSION_LOOKUP
;SYS$PERSONA_FIND
;SYS$PERSONA_MODIFY
;SYS$PERSONA_QUERY
;SYS$PERSONA_RESERVE
;SYS$POWER_CONTROL
;SYS$PROCESS_AFFINITY
;SYS$PROCESS_CAPABILITIES
;SYS$PROCESS_SCAN

;;; <summary>
;;;
;;; </summary>
;;; <param name="addressrange"></param>
;;; <returns></returns>
function SYS$PURGWS                     ,^val
    required in ^ref(addressrange)      ,D_ADDR
proc
	; if ever implmented only a single item is allowed not a array
    throw new ApplicationException("Not implemented!")
    freturn 0
endfunction

;SYS$PURGE_WS
;SYS$PUT
;SYS$PUTMSG

;;; <summary>
;;;
;;; </summary>
;;; <param name="efn"></param>
;;; <param name="channel"></param>
;;; <param name="func"></param>
;;; <param name="iosb"></param>
;;; <param name="astadr"></param>
;;; <param name="astparm"></param>
;;; <returns></returns>
function SYS$QIO                        ,^val, varargs
.ifdef dblnet
    in  ^val(efn)              ,i		; just pass 0
.else
    optional in  ^val(efn)              ,i
.endc
    required in  ^val(channel)          ,i
    required in  ^val(func)             ,i
.ifndef dblnet
    optional out ^ref(iosb)             ,int
    optional     ^val(astadr)           ,D_ADDR
    optional     ^val(astparm)          ,i
.endc
proc
    freturn sys$qiow(efn,channel,func)
endfunction

;;; <summary>
;;;
;;; </summary>
;;; <param name="efn"></param>
;;; <param name="channel"></param>
;;; <param name="func"></param>
;;; <param name="iosb"></param>
;;; <param name="astadr"></param>
;;; <param name="astparm"></param>
;;; <returns></returns>
function SYS$QIOW                       ,^val, varargs
.ifdef dblnet
	in  ^val(efn)			,i			; just pass 0 
.else
	optional in  ^val(efn)		,i
.endc
    required in  ^val(channel)          ,i
    required in  ^val(func)             ,i
.ifndef dblnet
    optional out ^ref(iosb)             ,int
    optional     ^val(astadr)           ,D_ADDR
    optional     ^val(astparm)          ,i
.endc
proc
    throw new ApplicationException("Not implemented!")
    freturn 0
endfunction

;SYS$READ
;SYS$READEF
;SYS$REGISTRY
;SYS$REGISTRYW
;SYS$RELEASE
;SYS$RELEASE_GALAXY_LOCK
;SYS$REMOVE
;SYS$REM_HOLDER
;SYS$REM_IDENT
;SYS$RENAME
;SYS$RESCHED
;SYS$RESUME

;;; <summary>
;;; 
;;; </summary>
;;; <param name="pidaddr"></param>
;;; <param name="processname"></param>
;;; <param name="rightsid"></param>
;;; <param name="name"></param>
;;; <param name="attrib"></param>
;;; <returns></returns>
.ifndef dblnet
function SYS$REVOKID			,^val
	optional inout ^ref(pidaddr)	,D_ADDR
	optional in processname         ,a
	optional inout ^ref(rightsid)	,long
	optional in name		,a
	optional out ^ref(attrib)	,int
proc
	throw new ApplicationException("Not implemented!")
	freturn 0
endfunction
.endc
;SYS$REWIND
;SYS$RMSRUNDWN.
;SYS$RPCC_64
;SYS$SCAN_INTRUSION
;SYS$SCHDWK
;SYS$SCHED

;;; <summary>
;;;
;;; </summary>
;;; <param name="fab"></param>
;;; <param name="erradr"></param>
;;; <param name="sucessadr"></param>
;;; <returns></returns>

function SYS$SEARCH                     ,^val
    required in ^ref(fab)               ,FABDEF
    default    ^val(erradr)            ,D_ADDR,0
    default   ^val(sucessadr)         ,D_ADDR,0
proc
    throw new ApplicationException("Not implemented!")
    freturn 0
endfunction

;SYS$SETAST
;SYS$SETCLUEVT
;SYS$SETDDIR
;SYS$SETDFPROT
;SYS$SETDTI
;SYS$SETDTIW
;SYS$SETEF
;SYS$SETEXV
;SYS$SETFLT
;SYS$SETFLT_64
;SYS$SETIME

;;; <summary>
;;;
;;; </summary>
;;; <param name="efn"></param>
;;; <param name="bintim"></param>
;;; <param name="astaddr"></param>
;;; <param name="user_arg"></param>
;;; <returns></returns>
.ifndef dblnet
function SYS$SETIMR                     ,^val
    default  in ^val(efn)               ,i,0
    required in ^ref(bintim)            ,long
    optional in ^ref(astaddr)           ,D_ADDR
    optional in ^val(user_arg)          ,i

proc
    throw new ApplicationException("Not implemented!")
    freturn 0
endfunction
.endc
;SYS$SETPRA
;SYS$SETPRI

;;; <summary>
;;;
;;; </summary>
;;; <param name="processid"></param>
;;; <param name="processname"></param>
;;; <param name="priority"></param>
;;; <param name="prevpriority"></param>
;;; <param name="basepriority"></param>
;;; <returns></returns>
.ifndef dblnet
function SYS$SETPRI                     ,^val
    optional inout ^ref(processid)      ,int
    optional in    processname          ,a
    required in    ^val(priority)       ,i
    optional out   ^ref(prevpriority)   ,int
    optional out   ^ref(basepriority)   ,int
proc
    throw new ApplicationException("Not implemented!")
    freturn 0
endfunction
.endc
;SYS$SETPRT
;SYS$SETPRT_64
;SYS$SETPRV
;SYS$SETRWM
;SYS$SETSHLV
;SYS$SETSTK
;SYS$SETSTK_64
;SYS$SETSWM
;SYS$SETUAI
;SYS$SETUP_AVOID_PREEMPT
;SYS$SET_DEFAULT_TRANS
;SYS$SET_DEFAULT_TRANSW
;SYS$SET_DEVICE
;SYS$SET_DEVICEW
;SYS$SET_IMPLICIT_AFFINITY
;SYS$SET_PROCESS_PROPERTIESW
;SYS$SET_RESOURCE_DOMAIN
;SYS$SET_RETURN_VALUE
;SYS$SET_SECURITY
;SYS$SET_SYSTEM_EVENT
;SYS$SET_UNWIND_TABLE
;SYS$SHOW_INTRUSION
;SYS$SIGNAL_ARRAY_64
;SYS$SNDERR

;;; <summary>
;;;
;;; </summary>
;;; <param name="efn"></param>
;;; <param name="func"></param>
;;; <param name="unused"></param>
;;; <param name="itemlist"></param>
;;; <param name="iosb"></param>
;;; <param name="astaddr"></param>
;;; <param name="user_arg"></param>
;;; <returns></returns>
.ifndef dblnet
function SYS$SNDJBC                     ,^val
    optional in ^val(efn)               ,i
    required in ^val(func)              ,i
    optional in ^val(unused)            ,i
    optional in ^ref(itemlist)          ,item_list
    optional in ^ref(iosb)              ,int
    optional in ^ref(astaddr)           ,D_ADDR
    optional in ^val(user_arg)          ,i
proc
	; if ever implmented only a single item is allowed not a arraylist
    throw new ApplicationException("Not implemented!")
    freturn 0
endfunction
.endc
;;; <summary>
;;;
;;; </summary>
;;; <param name="efn"></param>
;;; <param name="func"></param>
;;; <param name="unused"></param>
;;; <param name="itemlist"></param>
;;; <param name="iosb"></param>
;;; <param name="astaddr"></param>
;;; <param name="user_arg"></param>
;;; <returns></returns>
.ifndef dblnet
function SYS$SNDJBCW                    ,^val
    optional in ^val(efn)               ,i
    required in ^val(func)              ,i
    optional in ^val(unused)            ,i
    optional in ^ref(itemlist)          ,item_list
    optional in ^ref(iosb)              ,int
    optional in ^ref(astaddr)           ,D_ADDR
    optional in ^val(user_arg)          ,i
proc
	; if ever implmented only a single item is allowed not a arraylist
    throw new ApplicationException("Not implemented!")
    freturn 0
endfunction
.endc
;;; <summary>
;;;
;;; </summary>
;;; <param name="message"></param>
;;; <param name="channel"></param>
;;; <returns></returns>

function SYS$SNDOPR                     ,^val
    required in message                 ,a
    default in ^val(channel)           ,i,0
proc
.if ^defined(DBLNET) && !^defined(DBLV125)
	throw new ApplicationException("Not implemented!")
.else
	xcall syn_reportevent(D_EVENTLOG_INFORMATION_TYPE,message)
.endc
    freturn 0
endfunction

;SYS$SPACE
;SYS$START_ALIGN_FAULT_REPORT
;SYS$START_BRANCH
;SYS$START_BRANCHW
;SYS$START_TRANS
;SYS$START_TRANSW
;SYS$STOP_ALIGN_FAULT_REPORT
;SYS$STOP_SYS_ALIGN_FAULT_REPORT
;SYS$SUBSYSTEM
;SYS$SUSPND

;;; <summary>
;;;
;;; </summary>
;;; <param name="efn"></param>
;;; <param name="iosb"></param>
;;; <returns></returns>
.ifndef dblnet
function SYS$SYNCH                      ,^val
    optional in ^val(efn)               ,i
    optional in ^ref(iosb)              ,[*]int
proc
    throw new ApplicationException("Not implemented!")
    freturn 0
endfunction
.endc
;SYS$TIMCON
;SYS$TRANS_EVENT
;SYS$TRANS_EVENTW

;;; <summary>
;;;
;;; </summary>
;;; <param name="attr"></param>
;;; <param name="tablename"></param>
;;; <param name="logicalname"></param>
;;; <param name="accmode"></param>
;;; <param name="itemlist"></param>
;;; <returns></returns>
function SYS$TRNLNM                     ,^val
.ifdef dblnet
    in ^ref(attr)              ,int
.else
    optional in ^ref(attr)              ,int
.endc
    required in tablename               ,a
    required in logicalname             ,a
.ifndef dblnet
    optional in ^ref(accmode)           ,int
    optional in ^ref(itemlist)          ,item_list
.endc
proc
	; if ever implmented only a single item is allowed not a arraylist
    throw new ApplicationException("Not implemented!")
    freturn 0
endfunction

;SYS$TRUNCATE
;SYS$TSTCLUEVT
;SYS$ULKPAG
;SYS$ULKPAG_64
;SYS$ULWSET
;SYS$ULWSET_64
;SYS$UNWIND
;SYS$UPDSEC
;SYS$UPDSECW
;SYS$UPDSEC_64
;SYS$UPDSEC_64W
;SYS$VERIFY_PROXY
;SYS$WAIT

;;; <summary>
;;;
;;; </summary>
;;; <param name="efn"></param>
;;; <returns></returns>
function SYS$WAITFR                     ,^val
    ^val(efn)                           ,i
proc
    throw new ApplicationException("Not implemented!")
    freturn 0
endfunction

;SYS$WAKE
;SYS$WFLAND
;SYS$WFLOR
;SYS$WRITE

;;-----------------------------------------------------------------------------
;;Traceback Facility (TBK$) Routines (See Utility Routines Manual)

;TBK$I64_SYMBOLIZE
;TBK$ALPHA_SYMBOLIZE

;;-----------------------------------------------------------------------------
;;Text Processing Utility (TPU$) Routines (See Utility Routines Manual)

;TPU$CLEANUP
;TPU$CLIPARSE
;TPU$CLOSE_TERMINAL
;TPU$CONTROL
;TPU$EDIT
;TPU$EXECUTE_COMMAND
;TPU$EXECUTE_INIFILE
;TPU$FILEIO
;TPU$FILE_PARSE
;TPU$FILE_SEARCH
;TPU$HANDLER
;TPU$INITIALIZE
;TPU$MESSAGE
;TPU$PARSEINFO
;TPU$SIGNAL
;TPU$SPECIFY_ASYNC_ACTION
;TPU$TRIGGER_ASYNC_ACTION

;;; <summary>
;;;
;;; </summary>
;;; <param name="efn"></param>
;;; <returns></returns>
function TPU$TPU                     ,^val
	required in TpuCmd		    ,a
proc
	throw new ApplicationException("Not implemented!")
	freturn 0
endfunction

;FILEIO
;FILE_PARSE
;FILE_SEARCH
;HANDLER
;INITIALIZE
;USER

;;-----------------------------------------------------------------------------
;;DECdts Portable Applications Programming Interface (UTC_) Routines (See Utility Routines Manual)

;UTC_ABSTIME
;UTC_ADDTIME
;UTC_ANYTIME
;UTC_ANYZONE
;UTC_ASCANYTIME
;UTC_ASCGMTIME
;UTC_ASCLOCALTIME
;UTC_ASCRELTIME
;UTC_BINRELTIME
;UTC_BINTIME
;UTC_BOUNDTIME
;UTC_CMPINTERVALTIME
;UTC_CMPMIDTIME
;UTC_GETTIME
;UTC_GETUSERTIME
;UTC_GMTIME
;UTC_GMTZONE
;UTC_LOCALTIME
;UTC_LOCALZONE
;UTC_MKANYTIME
;UTC_MKASCRELTIME
;UTC_MKASCTIME
;UTC_MKBINRELTIME
;UTC_MKBINTIME
;UTC_MKGMTIME
;UTC_MKLOCALTIME
;UTC_MKRELTIME
;UTC_MKVMSANYTIME
;UTC_MKVMSGMTIME
;UTC_MKVMSLOCALTIME
;UTC_MULFTIME
;UTC_MULTIME
;UTC_POINTTIME
;UTC_RELTIME
;UTC_SPANTIME
;UTC_SUBTIME
;UTC_VMSANYTIME
;UTC_VMSGMTIME
;UTC_VMSLOCALTIME

